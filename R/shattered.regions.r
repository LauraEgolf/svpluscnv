#' Class to store shattered regions and information produced by shattered.regions and shattered.regions.cnv functions
#' @param regions.summary (list): a list of data.frames sumarizing the information of shattered regions found in each sample
#' @param high.density.regions (matrix): a numeric matrix representing high breakpoint density genomic bins in each sample (values 1 = high density break; 0 = normal)
#' @param high.density.regions.hc (matrix): a numeric matrix representing high breakpoint density genomic bins in each sample (values 1 = high density break; 0 = normal). 
#' Only those bins that overlap with high confidence regions defined in regions.summary are set to = 1 
#' @param seg.brk.dens (matrix): a numeric matrix representing the number of CNV segmentation breakpoints found in at genomic bins in each sample
#' @param sv.brk.dens (matrix): a numeric matrix representing the number of SV breakpoints found at genomic bins in each sample
#' @param seg.brk.common.dens (matrix): a numeric matrix representing the number of CNV breakpoints colocalizing SV breakpoints found at genomic bins in each sample
#' @param sv.brk.common.dens (matrix): a numeric matrix representing the number of SV breakpoints colocalizing CNV breakpoints found at genomic bins in each sample
#' @param segbrk (list): on object generated by seg.breaks function 
#' @param svbrk (list): on object generated by sv.breaks function 
#' @param common.brk (list): on object generated by match.breaks function 
#' @param segdat (data.frame): data.frame containing CNV segmentation data as provided in the input arguments
#' @param svdat (data.frame): data.frame containing SV calls as provided in the input arguments
#' @param param (list): list of configuration parameters provided or set as default
#' @return an instance of the class 'chromo.regs' containing breakpoint mapping onto genes
#' @export
chromo.regs <- setClass("chromo.regs",
                        representation(
                            regions.summary  = "list",
                            high.density.regions = "matrix",
                            high.density.regions.hc = "matrix",
                            seg.brk.dens = "matrix",
                            sv.brk.dens = "matrix",
                            seg.brk.common.dens = "matrix",
                            sv.brk.common.dens = "matrix",
                            segbrk = "list",
                            svbrk = "list",
                            common.brk = "list",
                            segdat = "data.frame",
                            svdat = "data.frame",
                            param = "list"
                        ))


setMethod("show","chromo.regs",function(object){
    
    conf <- table(names(unlist(lapply(unname(object@regions.summary),function(x) table(x[,"conf"])))))
    
    writeLines(paste("An object of class chromo.regs from svcnvplus containing the following stats:",
                "\nNumber of samples tested=",nrow(object@high.density.regions),
                "\nNumber of samples with shattered regions=",length(object@regions.summary),
                "\nNumber of samples with high-confidence shattered regions=",conf["HC"],
               "\nNumber of samples with low-confidence shattered regions=",conf["lc"]))
})



#' Caller for shattered genomic regions based on breakpoint densities
#' @param seg (data.frame) segmentation data with 6 columns: sample, chromosome, start, end, probes, segment_mean
#' @param sv (data.frame) structural variant table including  8 columns: sample, chrom1, pos1, strand1, chrom2, pos2, strand2, svclass
#' @param fc.pct (numeric) inherited from seg.breaks(); copy number change between 2 consecutive segments: i.e (default) cutoff = 0.2 represents a fold change of 0.8 or 1.2
#' @param min.seg.size (numeric) inherited from seg.breaks(); The minimun segment size (in base pairs) to include in the analysis 
#' @param min.num.probes (numeric) inherited from seg.breaks(); The minimun number of probes per segment to include in the analysis 
#' @param low.cov (data.frame) inherited from seg.breaks(), sv.breaks() and match.breaks; a data.frame (chr, start, end) indicating low coverage regions to exclude from the analysis
#' @param clean.brk (numeric) inherited from seg.breaks(); n of redundant breakpoints to filter out 
#' @param window.size (numeric) size in megabases of the genmome bin to compute break density 
#' @param slide.size (numeric) size in megabases of the sliding genmome window
#' @param num.seg.breaks (numeric) number of segmentation breakpoints per segments to be considered high-density break 
#' @param num.seg.sd (numeric) number of standard deviations above the sample average for num.seg.breaks
#' @param num.sv.breaks (numeric) number of SV breakpoints per segments to be considered high-density break  
#' @param num.sv.sd (numeric) number of standard deviations above the sample average for num.sv.breaks
#' @param num.common.breaks (numeric) number of common SV and segmentation breakpoints per segments to be considered high-density break
#' @param num.common.sd (numeric) number of standard deviations above the sample average for num.common.breaks
#' @param maxgap (numeric) inherited from match.breaks(); sets the maximum gap between co-localizing orthogonal breakpoints
#' @param chrlist (character) vector containing chromosomes to include in the analysis; if NULL all chromosomes available in the input will be included
#' @param interleaved.cut (numeric) 0-1 value indicating percentage of interleaved (non-contiguous) SV breakpoint pairs
#' @param dist.iqm.cut (numeric) interquantile average of the distance between breakpoints within a shattered region
#' @keywords chromothripsis, chromoplexy, chromosome shattering
#' @export
#' @examples
#' 
#' ## validate input data.frames
#' seg <- validate.seg(segdat_lung_ccle)
#' sv <- validate.sv(svdat_lung_ccle)
#' 
#' shattered.regions(seg,sv)


shattered.regions <- function(seg, 
                              sv,
                              fc.pct = 0.2, 
                              min.seg.size = 0, 
                              min.num.probes=0, 
                              low.cov = NULL,
                              clean.brk=NULL,
                              window.size = 10,
                              slide.size = 2,
                              num.seg.breaks = 6, 
                              num.seg.sd = 5,
                              num.sv.breaks = 6, 
                              num.sv.sd = 5,
                              num.common.breaks = 3, 
                              num.common.sd = 3,
                              maxgap=10000, 
                              chrlist=NULL, 
                              interleaved.cut = 0.5, 
                              dist.iqm.cut = 1e+05, 
                              verbose=TRUE){
  
 
  require(taRifx,quietly = TRUE,warn.conflicts = FALSE)  # contains remove.factors
  require(GenomicRanges,quietly = TRUE,warn.conflicts = FALSE)
  
  segdat <- validate.seg(seg)
  svdat <- validate.sv(sv)
  
  chr.lim <- chromosome.limit.coords(segdat)
  
  segbrk <- seg.breaks(seg = segdat, 
                       fc.pct = fc.pct, 
                       min.seg.size = min.seg.size, 
                       low.cov = low.cov, 
                       clean.brk = clean.brk,
                       verbose = verbose)
  
  svbrk <- sv.breaks(sv = svdat, 
                      low.cov = low.cov)
  
  common.brk <- match.breaks(segbrk,svbrk,
                             maxgap = maxgap, 
                             verbose = verbose)
  
  if(verbose) message("Mapping CNV breakpoints across the genome:")
  segbrk.dens <- break.density(segbrk,chr.lim = chr.lim, window.size = window.size, slide.size = slide.size, chrlist = chrlist,verbose = verbose)
  if(verbose) message("Mapping SV breakpoints across the genome:")
  svbrk.dens <- break.density(svbrk,chr.lim = chr.lim, window.size = window.size, slide.size = slide.size, chrlist = chrlist,verbose = verbose)

  common.brk1 <- common.brk2 <- list()
  common.brk1[["breaks"]] <- common.brk$brk1_match
  common.brk1[["brk.burden"]] <- common.brk$restab$matched.brk1
  common.brk2[["breaks"]] <- common.brk$brk2_match
  common.brk2[["brk.burden"]] <- common.brk$restab$matched.brk2
  names(common.brk1[["brk.burden"]]) <- names(common.brk2[["brk.burden"]])  <- rownames(common.brk$restab)
  
  if(verbose) message("Mapping CNV validated breakpoints across the genome:")
  segbrk.common.dens <- break.density(common.brk1,chr.lim = chr.lim, window.size = window.size, slide.size = slide.size, chrlist = chrlist,verbose = verbose)
  if(verbose) message("Mapping SV validated breakpoints across the genome:")
  svbrk.common.dens <- break.density(common.brk2,chr.lim = chr.lim, window.size = window.size, slide.size = slide.size, chrlist = chrlist,verbose = verbose)
  
  commonSamples <- intersect(names(segbrk$brk.burden),names(svbrk$brk.burden))
  if(length(commonSamples) == 0) stop("There is no common samples between seg and sv input datasets.") 
  
  # calculate inter quantile mean and standard deviation per sample
  iqmdata1<- rep(0,length(commonSamples))
  names(iqmdata1) <- commonSamples
  
  sddata1 <- iqmdata2 <- sddata2<- iqmdata3<- sddata3 <- iqmdata1
  iqmdata1[names(apply(segbrk.dens,1,IQM,lowQ=.1,upQ=.9))] <- apply(segbrk.dens,1,IQM,lowQ=.1,upQ=.9)
  sddata1[names(apply(segbrk.dens,1,IQSD,lowQ=.1,upQ=.9))]  <- apply(segbrk.dens,1,IQSD,lowQ=.1,upQ=.9)
  iqmdata2[names(apply(svbrk.dens,1,IQM,lowQ=.1,upQ=.9))] <- apply(svbrk.dens,1,IQM,lowQ=.1,upQ=.9)
  sddata2[names(apply(svbrk.dens,1,IQSD,lowQ=.1,upQ=.9))]  <- apply(svbrk.dens,1,IQSD,lowQ=.1,upQ=.9)
  iqmdata3[names(apply(segbrk.common.dens,1,IQM,lowQ=.1,upQ=.9))] <- apply(segbrk.common.dens,1,IQM,lowQ=.1,upQ=.9)
  sddata3[names(apply(segbrk.common.dens,1,IQSD,lowQ=.1,upQ=.9))]  <- apply(segbrk.common.dens,1,IQSD,lowQ=.1,upQ=.9)
  
  
  a <- sapply(commonSamples, function(i) names(which(segbrk.dens[i,] > iqmdata1[i]+num.seg.sd*sddata1[i] )))
  b <- sapply(commonSamples, function(i) names(which(segbrk.dens[i,] >= num.seg.breaks)))
  c <- sapply(commonSamples, function(i) names(which(svbrk.dens[i,] > iqmdata2[i]+num.sv.sd*sddata2[i] )))
  d <- sapply(commonSamples, function(i) names(which(svbrk.dens[i,] >= num.sv.breaks)))
  e <- sapply(commonSamples, function(i) names(which(segbrk.common.dens[i,] > iqmdata3[i]+num.common.sd*sddata3[i] )))
  f <- sapply(commonSamples, function(i) names(which(segbrk.common.dens[i,] >= num.common.breaks)))
  
  
  # condition for chromothripsis: at least n=breaks > 6 (sv SND seg)  AND n-breaks > u+2*sd (sv AND seg) 
  res <- sapply(commonSamples,function(i) Reduce(intersect, list(a[[i]],b[[i]],c[[i]],d[[i]],e[[i]],f[[i]])))

  highDensityRegions <- segbrk.dens[commonSamples,]
  highDensityRegions[] <- 0
  for(cl in commonSamples) highDensityRegions[cl,res[[cl]]] <- 1
  
  #res <- res[which(unlist(lapply(res,length)) >0)]
  if(verbose){
    message("Locating shattered regions...")
    pb <- txtProgressBar(style=3)
    cc <-0
    tot <- length(res)
  }
  
  restab  <- list()
  for(cl in names(res)){
    if(verbose) cc <- cc+1
    if(verbose) setTxtProgressBar(pb, cc/tot)
    if(length(res[[cl]]) > 0){
      tab <- as.data.frame(do.call(rbind,strsplit(res[[cl]]," ")))
      tab[,2]<-as.numeric(as.character(tab[,2]))
      tab[,3]<-as.numeric(as.character(tab[,3]))
      colnames(tab) <- c("chrom","start","end")
      tabgr = with(tab, GRanges(chrom, IRanges(start=start, end=end))) 
      hits = as.data.frame(GenomicAlignments::findOverlaps(tabgr,tabgr))
      
      agg <- aggregate(subjectHits ~ queryHits, hits, paste,simplify=FALSE)
      prev<-c(); cnum <- 0
      agglist <- list()
      for(x in agg$subjectHits){
        if(length(intersect(x,prev) > 0)){
          agglist[[cnum]] <- unique(c(x,prev))
          prev <- agglist[[cnum]]
        }else{
          cnum <- cnum+1
          agglist[[cnum]]<- x
          prev <-agglist[[cnum]]
        }
      }
      agglistUniq <- list()
      for(i in 1:length(agglist)){
        chrom <- as.character(unique(tab[as.numeric(agglist[[i]]),"chrom"]))
        start<-min( tab[as.numeric(agglist[[i]]),"start"])
        end<-max( tab[as.numeric(agglist[[i]]),"end"])
        segNum <- length(agglist[[i]])
        agglistUniq[[i]] <-  c(chrom,start,end,segNum)
      }
      tabmerged <- remove.factors(as.data.frame(do.call(rbind,agglistUniq)))
      for(i in 2:4) tabmerged[,i] <- as.numeric( tabmerged[,i] )
      colnames(tabmerged) <- c("chrom","start","end","nbins")
      restab[[cl]] <- tabmerged
    }
  }
  if(verbose) close(pb)
  
  results <- chromo.regs(
    regions.summary = restab,
    high.density.regions = highDensityRegions,
    high.density.regions.hc = matrix(),
    seg.brk.dens = segbrk.dens,
    sv.brk.dens = svbrk.dens,
    seg.brk.common.dens = segbrk.common.dens,
    sv.brk.common.dens = svbrk.common.dens,
    segbrk = segbrk,
    svbrk = svbrk,
    common.brk = common.brk,
    segdat = segdat,
    svdat = svdat,
    param = list(fc.pct = fc.pct,
                  min.seg.size = min.seg.size, 
                  min.num.probes=min.num.probes, 
                  low.cov = low.cov,
                  clean.brk=clean.brk,
                  window.size = window.size,
                  slide.size = slide.size, 
                  num.seg.breaks = num.seg.breaks,
                  num.seg.sd = num.seg.sd,
                  num.sv.breaks = num.sv.breaks,
                  num.sv.sd = num.sv.sd, 
                  num.common.breaks = num.common.breaks, 
                  num.common.sd = num.common.sd,
                  maxgap=maxgap,
                  chrlist=chrlist, 
                  interleaved.cut = interleaved.cut,
                  dist.iqm.cut = dist.iqm.cut)
        )
  
  results <- shattered.eval(results, interleaved.cut = interleaved.cut, dist.iqm.cut = dist.iqm.cut, verbose = verbose)
  
  return(results)
}

